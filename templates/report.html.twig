{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}


{% block body %}

    <div class="two-col-layout">
    <aside class="aside">
        <h1>Report</h1>
        <p>Alla rapporter för denna kurs finns här.</p>
        <ul>
            <li><a class="button blue-button" href="#kmom01">Kmom01</a></li>
            <li><a class="button blue-button" href="#kmom02">Kmom02</a></li>
            <li><a class="button blue-button" href="#kmom03">Kmom03</a></li>
            <li><a class="button blue-button" href="#kmom04">Kmom04</a></li>
            <li><a class="button blue-button" href="#kmom05">Kmom05</a></li>
            <li><a class="button blue-button" href="#kmom06">Kmom06</a></li>
            <li><a class="button blue-button" href="#kmom10">Kmom10</a></li>
        </ul>
    </aside>
    <main class="main">
        <article class="article">
            <br>
            <h2 id="kmom01">Kmom01 </h2>
                <p>Objektorienterad programmering eller OOPs hänvisar till språk som använder objekt i programmering. Jag har erfarenhet av att arbeta med objektorienterad programmering i python. De två huvudaspekterna av OOP är klasser och objekt. Medan klassen är ritningen, är en instans av en klass ett objekt. Klasser används för att skapa användardefinierade datastrukturer. Varje klass har en konstruktör. En konstruktor låter oss initiera ett objekts egenskaper när objektet skapas. Klassen har också attribut och metoder. Ett attribut definierar en viss egenskap hos ett objekt, element eller fil. Funktioner som definieras i klass kallas metoder.</p>
                <p>I PHP definieras klass genom att använda nyckelordet <i>class</i>, följt av klassens namn och ett par måsvingar ( <i>{}</i> ). Alla dess properties och metoder går in i måsvingarna. Klassnamn måste deklareras i <i>StudlyCaps</i> och metodnamn måste deklareras i <i>camelCase</i>. Syntaxen för att definiera konstruktorn är funktionen <i>__construct()</i>. <i>Namespaces</i> används för att undvika kollisionen med andra klasser med samma namn. Jag har skrivit php-koden för att skapa rutter i src/controller-mappen. Alla template filer som ska renderas sparas i templates mappen. Templatemotorn <i>twig</i> användas här.</p>
                <p>Jag hittade alla kapitlen i artikeln "PHP The Right Way" är viktiga. Men jag vill veta mer om <i>Coding Practices, Databases, Testing</i> och <i>Templating</i> i den här artikeln. Att definiera klass i PHP, skapa rutter är min TIL i denna kmom.</p>
            <br>            
            <h2 id="kmom02">Kmom02</h2>
                <p>Detta kursmoment lärde vi oss om de objektorienterade konstruktionerna arv, komposition, interface och trait.</p>
                <p><b>Arv </b> är en relation mellan två klasser. Det tillåter klasser att ärva egenskaper och metoder från andra klasser. Detta koncept främjar kodåteranvändbarhet och underlättar skapandet av en hierarkisk klassstruktur. Nyckelordet "extends" används för att implimentera arv i PHP.</p>
                <p><b> Komposition </b> är en annan typ av relation mellan klasser där en klass innehåller objekt från andra klasser som medlemsvariabler. I komposition finns det huvudsakligen två typer av kopplingar: tät koppling och lös koppling. Tät koppling innebär starka beroenden mellan delar av koden, vilket gör att ändringar i en del sannolikt påverkar andra. Lös koppling, å andra sidan, indikerar mindre beroende mellan koddelar, vilket gör det lättare att modifiera och underhålla dem oberoende.</p>
                <p>Ett <b> interface </b> definierar ett kontrakt för klasser, som specificerar en uppsättning metoder som en klass måste implementera. Det fungerar som en ritning för att definiera beteendet hos objekt utan att specificera deras interna implementeringsdetaljer. Nyckelordet "interface" används för att implimentera interfce i PHP.</p>
                <p>Ett <b>trait </b> är en mekanism för kodåteranvändning som gör det möjligt för utvecklare att dela metoder mellan klasser utan att använda arv. I PHP definieras ett trait med nyckelordet "trait" och ingår i en klass med nyckelordet "use".</p>
                <p>
                Jag skapade fyra klasser (Card, CardGraphic, CardHand och DeckOfCards) för att göra uppgiften i denna kmom. Klassen <b>Card </b>representerar ett spelkort. Den har en protected property (value), tre public properties (suites, minValue och maxValue) och en konstruktor som slumpmässigt tilldelar kortet en färg och ett värde om inget anges. Den har metoder för att dra ett nytt kort, hämta kortets värde, hämta en strängrepresentation av kortet och även hämta kortets färg.
                <p>
                Klassen <b>CardGraphic</b> ärver från klassen "Card" och har ytterligare en privat egenskap (representation) som mappar varje möjligt kortvärde till en motsvarande Unicode-teckenrepresentation av kortets färg och nummer. Det finns en metod, getAsString(), som returnerar en Unicode-teckenrepresentation av kortets färg och nummer.
                </p>
                <p>
                Klassen <b>CardHand</b> representerar en korthand, med metoder för att lägga till och ta bort kort, blanda samlingen, få fram antalet kort, få fram värden, färger och strängar för korten och slumpmässigt dra ett visst antal kort från samlingen. </p>
                </p>
                <p>
                Klassen <b>DeckOfCards</b> ärver från klassen "CardHand". Den har en metod, isCompleteDeck(), som kontrollerar om kortleken har alla 52 kort. Metoden beräknar det förväntade antalet kort baserat på kortets min- och maxvärden och jämför det med det faktiska antalet kort i kortleken.
                </p>
                <p>Fyra klasser används för att göra uppgiften. Det kanske är möjligt med färre klasser som jag inte kunde göra förrän nu. </p>
                <p>Jag har tyckt att arbetet med Symfony i objektorienterat PHP är strukturerat och organiserat, vilket gör det lättare att bygga och underhålla applikationer.</p>
                <p>Jag är bekant med Objektorienterad programmering då jag arbetade med objektorienterad Python i min tidigare kurs. Men att implementera OOP i PHP är nytt för mig och min TIL också i denna kmom.</p> 
                <br>
            <h2 id="kmom03">Kmom03</h2>
                <p>Ett kortspel som heter "Twenty One" utvecklas i denna kmom. Utvecklingen av spelet började med att skapa ett flödesschema, pseudokod och ett UML-klassdiagram. Dessa verktyg var till hjälp för mig att konceptualisera och modellera spelmekaniken samt planera kodstrukturen.
                UML-diagrammet var ett viktigt verktyg för att planera de klasser som krävs för detta projekt. Klasserna jag skapade för den senaste kmoms-uppgiften återanvänds tillsammans med ytterligare tre nya klasser. Flödesschemat och pseudokoden var också till hjälp för att förstå spelets flöde och villkoren för vinst/förlust, vilket är tillgängligt på <a class="link" href="{{ path('game_doc') }}">dokumentationssidan </a>.
                </p>
                <p>Jag är nöjd med hur jag strukturerade min kod och hur mitt spel blev. Det finns dock några element planerade i UML-diagrammet och flödesschemat som jag har tagit bort eller planerar att ta bort eftersom de är onödiga vid det här laget.
                Det finns utrymme för att förbättra 'checkWinStatus'-metoden i klassen 'Game21'. Den här metoden innehåller för många conditional statement och loopar. Efter att ha spenderat mer tid på att refaktorera koden bestämde jag mig för att ignorera dessa varningsmeddelanden.
                </p>
                <p>När jag började koda i ramverket Symfony stötte jag på många problem med renderingen, vilket gjorde mig frustrerad. Men efter att ha avslutat uppgiften i denna kmom har jag nu en bättre förståelse för hur Symfony fungerar och min självförtroendenivå har också ökat.</p>
                <p>Min TIL för denna kmom är cyklomatiska komplexitet och NPath komplexitet. Det cyklomatiska komplexitet mäter komplexiteten hos en metod genom att räkna antalet linjärt oberoende vägar genom dess källkod. NPath-komplexiteten mäter komplexiteten hos en metod som tar hänsyn till antalet möjliga exekveringsvägar genom koden, inklusive conditional statement och loopar. Dessa komplexiteter kan göra koden svårare att förstå och underhålla. </p>

            <h2 id="kmom04">Kmom04</h2>
                <p>Vi lärde oss om enhetstestning med ”PHPUnit” i denna kmom. Jag studerade om enhetstester i en av mina tidigare kurser "Objektorienterad programmering med Python". Så det var inte svårt att tillämpa begreppen på min kod med phpunit. Jag kunde uppnå 100% kodtäckning för mina klasser i kortspel och Game21 i verktyget php-code-coverage.</p>
                <p>Min kod var lätt att testa. Jag hade inga svårigheter att skriva kortspelets testkod. Eftersom metoderna i Game21 är mycket beroende av andra klasser, var testmetoderna för denna klass mer komplexa än för de andra klasserna. Vissa metoder, till exempel checkWinStatus(), behövs till och med för att täcka flera testfall. Jag har funderat på att skriva om några metoder för att förbättra testbarheten. Jag gjorde inga stora förändringar eftersom jag inte ville riskera att gå sönder något. Trots dessa utmaningar tillät testprocessen mig att identifiera och korrigera flera brister i min kod.</p>
                <p>Testbar kod är definitivt ett kännetecken för "snygg och ren kod", men de två begreppen är inte utbytbara. Testbar kod är kod som har skrivits på ett sätt som gör det enkelt att skriva tester för den. Det tenderar att vara modulärt, välstrukturerat och fokuserat på enskilda ansvarsområden, som alla bidrar till dess renlighet. När koden är lätt att testa betyder det vanligtvis att den är löst kopplad, vilket innebär att ändringar i en del av kodbasen inte krusar okontrollerat genom andra delar. Detta beror på att testbar kod ofta följer principer som tillförsel av beroende och separation av problem, vilket främjar flexibilitet och underhållbarhet. Å andra sidan är "snygg och ren kod" kod som är lätt att läsa, förstå och ändra. "Snygg och ren kod" följer etablerade kodningsstandarder och bästa praxis, t.ex. namnkonventioner, kodformatering och kommentarer. Verktyg som php-cs-fixer, phpstan och phpmd hjälper oss att skriva "snygg och ren" kod. Det går att skriva snygg och ren kod som är svår att testa, t.ex. om koden är tätt kopplad eller saknar tydlig åtskillnad av problem.</p>
                <p>Min TIL för denna kmom handlar om PHPDoc. PHPDoc är en dokumentationsgenerator som används i PHP för att dokumentera kod i ett standardiserat format. Det tillåter utvecklare att dokumentera funktioner, metoder, klasser och variabler med hjälp av speciella kommentarer i koden. Dessa kommentarer börjar med /** och slutar med */, och de använder specifika taggar för att tillhandahålla information som parametertyper, returtyper, beskrivningar och eventuell ytterligare metadata. Att använda PHPDoc-kommentarer hjälper till att förbättra kodens läsbarhet och underhållbarhet genom att tillhandahålla tydlig och konsekvent dokumentation.</p>
            <h2 id="kmom05">Kmom05</h2>
                <p>I denna kmom har vi lärt oss Doctrine, ett ORM-bibliotek (Object-Relational Mapping) för PHP, som erbjuder utvecklare en kraftfull verktygsuppsättning för databasinteraktioner. I sin kärna förenklar Doctrine processen att mappa databastabeller till PHP-objekt, vilket möjliggör sömlös interaktion mellan applikationskod och databasdata. Jag följde föreläsningen och stötte inga problem när jag arbetade igenom övningen eller uppgiften med Symfony and Doctrine.</p>
                <p>I början av kmom kände jag att det kanske inte var lätt att arbeta med Doctrine. Jag följde föreläsningen och valde SQLite istället för MariaDB för att slippa stöta på några svårigheter. Jag blev förvånad över att det inte var så svårt att arbeta med Doctrine som jag trodde innan. Arbetet med ORM för att skapa en CRUD-applikation gick bra. Jag är nöjd med användargränssnittet som jag skapade i denna kmom.</p>
                <p>Min TIL för denna kmom är Doctrine. Doctrine har flera fördelar jämfört med lågnivådatabasåtkomstlager PHP PDO. PHP PDO är lätt och lämplig för enkla databasoperationer och erbjuder mer kontroll på SQL-nivå. Å andra sidan är Doctrine ett fullfjädrat ORM-bibliotek som ger en högre abstraktionsnivå genom att mappa databastabeller till PHP-objekt, vilket gör att utvecklare kan arbeta med databaser med hjälp av välbekanta objektorienterade paradigm. Dessutom utmärker Doctrine i komplexa applikationer där objektorienterad design och abstraktion prioriteras, vilket underlättar uppgifter som datavalidering, relationshantering och databasportabilitet. Detta gör koden enklare och lättare att förstå. Dessutom kan man använda samma kod för att interagera med olika databassystem som SQLite, MariaDB, etc i ORM-verktyg.</p>
            <h2 id="kmom06">Kmom06</h2>
                <p>
                I den här kmom analyserade vi PhpMetrics och Scrutinizer-rapporterna för att utvärdera kodkvaliteten och identifiera förbättringsområden i vårt projekt. PhpMetrics visade sig vara ett robust verktyg som erbjuder omfattande insikter i olika aspekter av vår kod. Nyckelmått som LOC (lines of Code), underhållsindex, komplexitet och klassrankning är bekvämt samlade på en enda sida. Det känns som att man behöver lägga mer tid på att läsa och förstå rapporten.
                Jag tyckte att det inte var lätt att förstå graferna.
                </p>
                <p>
                Jag tycker att Scrutinizer-rapporten är mycket lättare att förstå och greppa. Jag tyckte att Scrutinizer var till stor hjälp för att identifiera och förklara problem i koden. Genom att åtgärda dessa problem kunde jag förbättra det övergripande betyget.
                </p>
                <p>
                Jag gillar båda verktygen och har lärt mig att man inte ska använda metriska mått isolerat, utan i kombination med andra för att få en bättre bild. Jag använde båda verktygen och min Scrutinizer-poäng ökade från 9,84 till 9,89 och kodtäckningen ökade från 25 % till 30 %. Men jag tyckte att Scrutinizer var lättare att förstå och agera på än PHPMetrics.
                </p>
                <p>
                Att använda verktygen PHPMetrics och Scrutinizer, och begreppen kodlukt (code smell) är min TIL i denna kmom. Kodlukt hänvisar till funktioner eller symptom i koden som tyder på potentiella design- eller implementeringsproblem. Även om det inte är buggar i sig, framhäver kodlukt områden som kan försämra kodkvaliteten och underhållsbarheten över tid. Exempel inkluderar duplicerad kod, alltför långa och komplexa metoder eller klasser och inkonsekventa namnkonventioner. Genom att identifiera och adressera dessa kodlukter genom refactoring kan vi avsevärt förbättra kodläsbarheten och underhållsbarheten.
                </p>
            <h2 id="kmom10">Kmom10</h2>
            <h3>Requirement 1, 2, 3</h3>
            
        </article>
    </main>   
</div>

{% endblock %}