{% extends "adventure/adventure-page.html.twig" %}

{% block main %}
    <h1>Database</h1>

    {# <p>
    - An image of an ER diagram of the tables.
    - For each table, describe in one sentence what is stored in the table.
    - Explain how you resolved any relationships between the tables.
    - Tell us if you used SQLite or another database.
    - Tell us if you did unit tests against the database.
    - Tell us if/how you succeeded in unit testing on Scrutinizer with the database.
    - Tell in your own words (about 15 sentences) about how you see the advantages, disadvantages, similarities and differences between ORM and the way we worked with the database in the database course.
    </p> #}

    <p>
        I utilized SQLite to create a database for the game. Two tables: <i>room</i> and <i>item</i> are created to store comprehensive information about the rooms and items featured in the adventure game.
        An ER diagram illustrating both tables is given below.
    </p>
    <br>
    <figure class="proj-figure">
        <img alt="ER diagram" src="{{ asset('img/adventure/proj_er.png') }}"
        style="width: 30%;">
        <figcaption class="proj-fig-caption">
            ER diagram for the table Room and Item
        </figcaption>
    </figure>
    <p>
        The <i>room</i> table includes fields for the room <i>name</i>, a brief <i>description</i>, a representative <i>image</i> ,and the adjacent rooms in the north, east, south, and west directions.
        If a particular direction lacks a connecting room, the value "null" is assigned.
        The inspect column of the table contains a more detailed description of each room.
    </p>

    <p>
        The <i>item</i> table stores the item name, a short description, and an associated image for each item in the adventure game.
        The room column specifies the location where the item can be found.
    </p>

    <p>
        While designing the tables, I intentionally avoided establishing relationships through foreign keys or other mechanisms.
        My goal was to maintain simplicity within the tables to facilitate the creation, updating,
        querying and deleting of records.
        I opted to utilize Doctrine, an ORM framework, to define object-oriented classes that correspond to the database tables.
    </p>
    <br>
    <h2>Unit testing</h2>

    <p>
        To test the interactions between Doctrine and the tables in the database,
        I have created a series of unit tests for all Entities generated by the ORM framework based on the table structure.
        These tests can be found in the <i>report/tests/Entity/</i> folder.
        It's important to note that my tests have certain limitations as they only verify whether the setter and getter methods of each property return the expected output.
        In a real-world scenario, additional tests would be created to ensure a well-functioning interaction between the application and the database.
        However, considering the current complexity and size of the application, and taking into account time and skill limitations, I believe my unit testing is sufficient.
    </p>
    <p>
        The unit tests achieve more than 96% coverage in PhpMetrics.
        I excluded the directories <i>src/Controller</i>, <i>src/Repository</i>, and <i>src/Command</i> from the PhpMetrics evaluation,
        as explained in the report for kmom10.
        Scrutinizer estimates the coverage at 34%, which shows an 4% increase since the last report. Almost all classes created for the Adventure Game project score a A in the Scrutinizer report.
    </p>
    <br>
    <h2>Advantages and drawbacks of ORM</h2>

    <p>I opted to use the ORM framework, Doctrine rather than a data access abstraction layer like PHP PDO. The primary reason for this choice is that Doctrine employs an object-oriented approach to database management. This allows me to interact with the database using PHP objects instead of SQL queries, thereby simplifying the code and making it easier to integrate with other classes.</p>

    <p>Doctrine offers several advantages over PHP PDO. One significant benefit is its ability to automate many common database tasks, such as CRUD (create, read, update, delete) operations, data validation, and query generation. This automation reduces the amount of repetitive code needed, streamlining and accelerating development.</p>

    <p>Additionally, ORM frameworks like Doctrine provide a layer of abstraction that allows developers to work with various database systems without substantial changes to the application code. This abstraction enhances code maintainability and offers flexibility in choosing the database backend, whether it's SQLite, MariaDB, or another system. Moreover, ORM frameworks typically include built-in mechanisms for data validation, input sanitization, and protection against common security vulnerabilities such as SQL injection. These features help ensure data integrity and improve application security.</p>

    <p>However, using ORM frameworks also comes with significant drawbacks. One major challenge is the steep learning curve associated with mastering the framework. While ORM frameworks are excellent for handling straightforward CRUD operations, they can become complex when dealing with intricate queries, joins, or performance optimizations. Crafting efficient queries with an ORM requires a deep understanding of the framework's query generation capabilities, which can be time-consuming to acquire. After several weeks of working with Doctrine in this course, I have grasped the basics, but advancing beyond this level has proven challenging and time-intensive. Consequently, I aimed to keep my database tables as simple as possible.</p>

    <p>Another drawback of ORM frameworks is their tendency to provide a generic interface for working with different databases. This can limit access to advanced features or optimizations specific to a particular database system. Furthermore, the additional abstraction layer introduced by ORM frameworks can negatively impact performance. The automatic query generation and mapping processes may not always produce the most optimized SQL queries, potentially leading to slower application performance.</p>



{% endblock %}
