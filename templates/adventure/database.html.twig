{% extends "adventure/adventure-page.html.twig" %}

{% block main %}
    <h1>Database</h1>

    <p>
        Doctrine, an ORM framework, defines the object-oriented classes corresponding to the database tables. Doctrine allows users to interact with the database using PHP objects instead of SQL queries. 
         I utilized SQLite to create a database for the game.Two relational database tables - Room and Item - are created to store
         the required features of the adventure game. The Room table has the following columns - name, description, image, inspect,
         north, east, south, and west.  The name, description, image, and inspect columns contain a name, a short description, a
         representative image, and a detailed description of the room, respectively. The north, east, south, and west columns contain
         the name of the adjacent room in the corresponding directions. If there is no room in any direction, the corresponding column
         contains 'null'. The Item table columns are name, description, image, and room.  The name, description, and image columns
         contain a name, a short description, and a representative image of the item, respectively. The room column specifies the
         location where the item can be found. For simplicity to facilitate the creation, updating, querying, and deleting of rows foreign keys are avoided.
         An ER diagram illustrating both database tables is given below.
    </p>
    <br>
    <figure class="proj-figure">
        <img alt="ER diagram" src="{{ asset('img/adventure/proj_er.png') }}"
        style="width: 30%;">
        <figcaption class="proj-fig-caption">
            ER diagram for the table Room and Item
        </figcaption>
    </figure>
    <p>
    
    </p>
    <br>
    <h2>Unit testing</h2>

    <p>
        Several unit tests are written to test whether the setter and getter methods of each property 
        (database column) return the expected output. These tests are available in the <i>report/tests/Entity/</i>
         folder. The unit tests achieve more than 90% coverage in PhpMetrics. I excluded the directories <i>src/Controller</i>, <i>src/Repository</i>, and <i>src/Command</i>
         from the PhpMetrics evaluation. Scrutinizer estimates the coverage at 34%, which is 4% greater than the coverage of the last kmom. Almost all classes created for the Adventure Game project score an A in the Scrutinizer report.
    </p>
    <br>
    <h2>Advantages and disadvantages of ORM</h2>

    <p>
    Doctrine allows us to interact with the database using PHP objects instead of SQL queries. Hence, 
    Doctrine simplifies the code and makes it easier to integrate with other classes. Doctrine offers 
    several advantages over PHP PDO. One significant benefit is its ability to automate many database tasks, 
    such as CRUD operations, query generation, and data validation. This automation reduces repetitive code 
    and helps streamline and accelerate development. The Doctrine provides an abstraction layer that allows 
    developers to work with various database systems without substantial changes to the application code. 
    This abstraction enhances code maintainability and offers flexibility in choosing the database backend, 
    whether it's SQLite, MariaDB, or another database. ORM frameworks also include built-in mechanisms for data 
    validation, input sanitization, and protection against common security vulnerabilities such as SQL injection. 
    These features help ensure data integrity and improve application security. Moreover, Doctrine allows migration
     support. It is easier to handle changes in the database structure over time without manually writing SQL scripts.
    </p>
    <p>
    However, using ORM frameworks also comes with significant drawbacks. One major challenge is the steep learning curve 
    associated with mastering the framework. Moreover, Doctrine's configuration and maintenance can become complex and 
    challenging to manage in large projects with many entities and relationships. ORM frameworks provide a generic 
    interface for working with different databases which can limit access to advanced features or optimizations 
    specific to a particular database system.
    </p>


{% endblock %}
